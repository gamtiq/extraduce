{"version":3,"file":"extraduce.umd.development.js","sources":["../src/index.ts"],"sourcesContent":["let extraActionType = '/#/extraduce|#|extra-action//';\n\n/**\n * Return type of action that is used to wrap several actions to be processed.\n * \n * @return\n *   Type of action that is used to wrap several actions to be processed.\n */\nexport function getExtraActionType(): string {\n    return extraActionType;\n}\n\n/**\n * Change type of action that is used to wrap several actions to be processed.\n * \n * @param actionType\n *   New value of type.\n */\nexport function setExtraActionType(actionType: string): void {\n    extraActionType = actionType;\n}\n\nexport interface ExtraAction<A = unknown, EA = A> {\n    type: string;\n    payload: Array<A | EA>;\n}\n\n/**\n * Create action that is used to wrap several actions to be processed.\n * \n * @param actionList\n *   Actions to be processed.\n * @return\n *   Created action.\n */\nexport function extraAction<A = unknown, EA = A>(...actionList: Array<A | A[] | EA | EA[]>): ExtraAction<A, EA> {\n    const payload: Array<A | EA> = [];\n\n    for (let i = 0, len = actionList.length; i < len; i++) {\n        const action = actionList[i];\n        // eslint-disable-next-line multiline-ternary\n        payload.push(...(Array.isArray(action) ? action : [action]));\n    }\n\n    return {\n        type: extraActionType,\n        payload\n    };\n}\n\n/**\n * Check whether passed value represents an action that wraps several actions to be processed.\n * \n * @param value\n *   Value to be checked.\n * @return\n *   `true` if the passed value represents an action that wraps several actions to be processed.\n */\nexport function isExtraAction<A = unknown, EA = A>(value: unknown): value is ExtraAction<A, EA> {\n    return Boolean(value)\n        && (value as Record<string, unknown>).type === extraActionType\n        && Array.isArray((value as Record<string, unknown>).payload);\n}\n\n\n/**\n * Possible values of processing step.\n */\nexport enum ProcessStep {\n    process = 'process',\n    prepareAction = 'prepareAction',\n    filterAction = 'filterAction',\n    transformAction = 'transformAction',\n    prereduce = 'prereduce',\n    reducerExtraArgs = 'reducerExtraArgs',\n    reduce = 'reduce',\n    postreduce = 'postreduce',\n    history = 'history'\n}\n\nexport type Reducer<S = unknown, A = unknown, R = S> = (state: S, action: A, ...extraArgs: unknown[]) => R;\n\n/** Describes base process data. */\nexport interface BaseProcessData<S = unknown, A = unknown, EA = A> {\n    /** Supplementary data (value of `settings.data`). */\n    data: unknown;\n    /** List of fulfilled operations (processed actions). */\n    history: Array<HistoryItem<S, A, EA>> | null;\n    /** Settings that have used to define features of processing. */\n    settings: ExtraduceSettings<S, A, EA>;\n    /** Source action that is passed in reducer, or list of actions to be processed. */\n    sourceAction: EA | EA[];\n    /** Source (wrapped) reducer. */\n    sourceReducer: Reducer<S, A>;\n    /** Source state that is passed in reducer. */\n    sourceState: S;\n    /** Current state. */\n    state: S;\n    /** Current processing step. */\n    step: ProcessStep;\n    /** `true`, when current step is ending. */\n    stepEnd: boolean;\n    /** Enumeration of possible values of processing step. */\n    stepSet: typeof ProcessStep;\n    /** `true`, when current step is starting. */\n    stepStart: boolean;\n}\n\n/** Describes current status of data processing. */\nexport interface ProcessData<S = unknown, A = unknown, EA = A> extends BaseProcessData<S, A, EA> {\n    /** Current action that is processed. */\n    action: A | A[] | EA | EA[];\n    /** Index of current action. */\n    actionIndex: number;\n    /** Whether current action is the first action in processing. */\n    firstAction: boolean;\n    /** Whether current action is the last action in processing. */\n    lastAction: boolean;\n    /** State after source (wrapped) reducer is applied for the current action. */\n    reducedState: S;\n    /** State before source (wrapped) reducer is applied for the current action. */\n    startState: S;\n    /** Whether current action is valid and should be passed for reducing. */\n    validAction: boolean;\n}\n\nexport type ProcessingDataField = 'step' | 'stepEnd' | 'stepSet' | 'stepStart' | 'validAction';\n\n/** Describes fulfilled operation (processed action). */\nexport interface HistoryItem<S = unknown, A = unknown, EA = A> extends Omit<ProcessData<S, A, EA>, ProcessingDataField> {\n    /** Time in milliseconds when operation data were saved in history. */\n    time: number;\n}\n\nexport type ReturnUnknown = () => unknown;\n\nexport type ProcessContext<S = unknown, A = unknown, EA = A> = BaseProcessData<S, A, EA> | ProcessData<S, A, EA>;\n\nexport type ActionTransformer<S = unknown, A = unknown, EA = A> = ((action: A | A[] | EA | EA[], data: ProcessData<S, A, EA>) => A | A[]) | ((action: A | A[] | EA | EA[]) => A | A[]);\n\nexport type DataHandler<S = unknown, A = unknown, EA = A> = ((state: S, action: A | A[], data: ProcessData<S, A, EA>) => unknown) | ((state: S, action: A | A[]) => unknown) | ((state: S) => unknown) | ReturnUnknown;\n\nexport type FilterAction<S = unknown, A = unknown, EA = A> = ((action: A | A[] | EA | EA[], data: ProcessData<S, A, EA>) => boolean) | ((action: A | A[] | EA | EA[]) => boolean) | (() => boolean);\n\nexport type GetReducerExtraArgs<S = unknown, A = unknown, EA = A> = ((data: ProcessData<S, A, EA>) => unknown) | ReturnUnknown;\n\nexport type StepHandler<S = unknown, A = unknown, EA = A> = ((step: ProcessStep, data: ProcessContext<S, A, EA>) => unknown) | ((step: ProcessStep) => unknown) | ReturnUnknown;\n\n/**\n * Settings to define features of processing.\n */\nexport interface ExtraduceSettings<S = unknown, A = unknown, EA = A> {\n    /**\n     * Any supplementary data that should be available in processing.\n     */\n    data?: unknown;\n    /**\n     * Function that should be called to test whether current action is valid and should be passed for reducing.\n     * If the function returns `false`, the current action will be ignored (will not be passed into source reducer).\n     * This function is called after a function that is specified in `prepareAction` setting.\n     */\n    filterAction?: FilterAction<S, A, EA>;\n    /**\n     * Size of list of fulfilled operations (processed actions).\n     * `0` (default value) means that data about operations should not be saved in the list.\n     * Negative value (for example `-1`) means that list size is not restricted.\n     */\n    historySize?: number;\n    /**\n     * Function that should be called at the end of each processing step.\n     */\n    onStepEnd?: StepHandler<S, A, EA>;\n    /**\n     * Function that should be called at the start of each processing step.\n     */\n    onStepStart?: StepHandler<S, A, EA>;\n    /**\n     * Function that should be called after source (wrapped) reducer.\n     * State returned by source reducer and current action will be passed into the function.\n     */\n    postreduce?: DataHandler<S, A, EA>;\n    /**\n     * Whether result of `postreduce` function should be used as new state in further processing.\n     * Default value is `false`.\n     */\n    postreduceValueIsState?: boolean;\n    /**\n     * Function that should be called to prepare current action for further processing before filtering.\n     * Value returned by the function will be used as new current action.\n     */\n    prepareAction?: ActionTransformer<S, A, EA>;\n    /**\n     * Function that should be called before source (wrapped) reducer.\n     */\n    prereduce?: DataHandler<S, A, EA>;\n    /**\n     * Whether result of `prereduce` function should be used as new state in further processing.\n     * Default value is `false`.\n     */\n    prereduceValueIsState?: boolean;\n    /**\n     * Whether an array that is passed as action should be treated as list of actions that should be processed separately.\n     * Default value is `true`.\n     */\n    processActionArray?: boolean;\n    /**\n     * Supplementary arguments that should be passed into source (wrapped) reducer besides state and action.\n     * Or a function that returns such arguments.\n     */\n    reducerExtraArgs?: unknown | GetReducerExtraArgs<S, A, EA>;\n    /**\n     * Whether processing of an action that has a falsy value should be skipped.\n     * Default value is `true`.\n     * The corresponding check is made before calling a function that is specified in `filterAction` setting.\n     */\n    skipFalsyAction?: boolean;\n    /**\n     * Function that should be called to transform current valid action after filtering.\n     * Value returned by the function will be used as new current action for further processing.\n     */\n    transformAction?: ActionTransformer<S, A, EA>;\n}\n\n/**\n * Wrap passed reducer to add pre- and post-processing.\n *\n * @param sourceReducer\n *   Source reducer that should be wrapped.\n * @param [settings]\n *   Settings to customize wrapping operation and features of created reducer.\n * @return\n *   New created reducer that can be used instead of source reducer.\n */\nexport default function extraduce<S = unknown, A = unknown, EA = A>(sourceReducer: Reducer<S, A>, settings?: ExtraduceSettings<S, A, EA>): Reducer<S, EA | EA[]> {\n    const options: ExtraduceSettings<S, A, EA> = settings || {};\n    if (! ('processActionArray' in options)) {\n        options.processActionArray = true;\n    }\n    if (! ('skipFalsyAction' in options)) {\n        options.skipFalsyAction = true;\n    }\n    let { historySize } = options;\n    if (typeof historySize !== 'number') {\n        historySize = 0;\n    }\n    const actionHistory: Array<HistoryItem<S, A, EA>> | null = historySize\n        ? []\n        : null;\n\n    return function reducer(sourceState, sourceAction) {\n        const { filterAction, onStepEnd, onStepStart, postreduce, postreduceValueIsState, prepareAction, prereduce, prereduceValueIsState,\n            processActionArray, reducerExtraArgs, skipFalsyAction, transformAction } = options;\n        // eslint-disable-next-line no-nested-ternary\n        const actionList = Array.isArray(sourceAction) && processActionArray\n            ? sourceAction\n            : (isExtraAction<A, EA>(sourceAction)\n                ? sourceAction.payload\n                : [sourceAction]\n            );\n        let state = sourceState;\n        const stepSet = ProcessStep;\n        const data = {\n            sourceReducer,\n            sourceState,\n            sourceAction,\n            state,\n            history: actionHistory,\n            stepSet,\n            settings: options,\n            data: options.data,\n            stepStart: false,\n            stepEnd: false\n        } as ProcessData<S, A, EA>;\n\n        function startStep(step: ProcessStep, context: ProcessContext<S, A, EA>) {\n            context.step = step;\n            if (typeof onStepStart === 'function') {\n                context.stepStart = true;\n                onStepStart(step, context);\n                context.stepStart = false;\n            }\n        }\n\n        function endStep(step: ProcessStep, context: ProcessContext<S, A, EA>) {\n            if (typeof onStepEnd === 'function') {\n                context.stepEnd = true;\n                onStepEnd(step, context);\n                context.stepEnd = false;\n            }\n        }\n\n        startStep(stepSet.process, data as BaseProcessData<S, A, EA>);\n\n        for (let i = 0, len = actionList.length; i < len; i++) {\n            let action: A | A[] | EA | EA[] = actionList[i];\n            data.action = action;\n            data.actionIndex = i;\n            data.firstAction = i === 0;\n            data.lastAction = i === len - 1;\n            data.validAction = true;\n            data.startState = data.reducedState = state;\n\n            if (typeof prepareAction === 'function') {\n                startStep(stepSet.prepareAction, data);\n                action = data.action = prepareAction(action, data);\n                endStep(stepSet.prepareAction, data);\n            }\n            if (skipFalsyAction && ! action) {\n                data.validAction = false;\n            }\n            else if (typeof filterAction === 'function') {\n                startStep(stepSet.filterAction, data);\n                data.validAction = filterAction(action, data);\n                endStep(stepSet.filterAction, data);\n            }\n\n            if (data.validAction) {\n                let value;\n                if (typeof transformAction === 'function') {\n                    startStep(stepSet.transformAction, data);\n                    action = data.action = transformAction(action, data);\n                    endStep(stepSet.transformAction, data);\n                }\n                if (typeof prereduce === 'function') {\n                    startStep(stepSet.prereduce, data);\n                    value = prereduce(state, action as A | A[], data);\n                    if (prereduceValueIsState) {\n                        state = data.state = value as S;\n                    }\n                    endStep(stepSet.prereduce, data);\n                }\n\n                value = [state, action];\n                if (reducerExtraArgs) {\n                    startStep(stepSet.reducerExtraArgs, data);\n                    value = value.concat(\n                        typeof reducerExtraArgs === 'function'\n                            ? reducerExtraArgs(data)\n                            : reducerExtraArgs\n                    );\n                    endStep(stepSet.reducerExtraArgs, data);\n                }\n                startStep(stepSet.reduce, data);\n                state = data.state = sourceReducer(...value as [S, A, ...unknown[]]);\n                data.reducedState = state;\n                endStep(stepSet.reduce, data);\n\n                if (typeof postreduce === 'function') {\n                    startStep(stepSet.postreduce, data);\n                    value = postreduce(state, action as A | A[], data);\n                    if (postreduceValueIsState) {\n                        state = data.state = value as S;\n                    }\n                    endStep(stepSet.postreduce, data);\n                }\n                if (actionHistory) {\n                    startStep(stepSet.history, data);\n                    if (actionHistory.length === historySize) {\n                        actionHistory.shift();\n                    }\n                    value = Object.assign({time: new Date().getTime()}, data) as HistoryItem<S, A, EA> & Partial<Pick< ProcessData<S, A, EA>, ProcessingDataField >>;\n                    delete value.step;\n                    delete value.stepEnd;\n                    delete value.stepSet;\n                    delete value.stepStart;\n                    delete value.validAction;\n                    actionHistory.push(value);\n                    endStep(stepSet.history, data);\n                }\n            }\n        }\n\n        endStep(stepSet.process, data as BaseProcessData<S, A, EA>);\n\n        return state;\n    };\n}\n\nexport {extraduce};\n"],"names":["extraActionType","getExtraActionType","setExtraActionType","actionType","extraAction","payload","i","len","length","action","push","Array","isArray","type","isExtraAction","value","Boolean","ProcessStep","extraduce","sourceReducer","settings","options","processActionArray","skipFalsyAction","historySize","actionHistory","reducer","sourceState","sourceAction","filterAction","onStepEnd","onStepStart","postreduce","postreduceValueIsState","prepareAction","prereduce","prereduceValueIsState","reducerExtraArgs","transformAction","actionList","state","stepSet","data","history","stepStart","stepEnd","startStep","step","context","endStep","process","actionIndex","firstAction","lastAction","validAction","startState","reducedState","concat","reduce","shift","Object","assign","time","Date","getTime"],"mappings":"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"}