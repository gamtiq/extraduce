{"version":3,"file":"extraduce.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["let extraActionType = '/#/extraduce|#|extra-action//';\n\n/**\n * Return type of action that is used to wrap several actions to be processed.\n * \n * @return\n *   Type of action that is used to wrap several actions to be processed.\n */\nexport function getExtraActionType(): string {\n    return extraActionType;\n}\n\n/**\n * Change type of action that is used to wrap several actions to be processed.\n * \n * @param actionType\n *   New value of type.\n */\nexport function setExtraActionType(actionType: string): void {\n    extraActionType = actionType;\n}\n\nexport interface ExtraAction<A = unknown, EA = A> {\n    type: string;\n    payload: Array<A | EA>;\n}\n\n/**\n * Create action that is used to wrap several actions to be processed.\n * \n * @param actionList\n *   Actions to be processed.\n * @return\n *   Created action.\n */\nexport function extraAction<A = unknown, EA = A>(...actionList: Array<A | A[] | EA | EA[]>): ExtraAction<A, EA> {\n    const payload: Array<A | EA> = [];\n\n    for (let i = 0, len = actionList.length; i < len; i++) {\n        const action = actionList[i];\n        // eslint-disable-next-line multiline-ternary\n        payload.push(...(Array.isArray(action) ? action : [action]));\n    }\n\n    return {\n        type: extraActionType,\n        payload\n    };\n}\n\n/**\n * Check whether passed value represents an action that wraps several actions to be processed.\n * \n * @param value\n *   Value to be checked.\n * @return\n *   `true` if the passed value represents an action that wraps several actions to be processed.\n */\nexport function isExtraAction<A = unknown, EA = A>(value: unknown): value is ExtraAction<A, EA> {\n    return Boolean(value)\n        && (value as Record<string, unknown>).type === extraActionType\n        && Array.isArray((value as Record<string, unknown>).payload);\n}\n\n\n/**\n * Possible values of processing step.\n */\nexport enum ProcessStep {\n    process = 'process',\n    prepareAction = 'prepareAction',\n    filterAction = 'filterAction',\n    transformAction = 'transformAction',\n    prereduce = 'prereduce',\n    reducerExtraArgs = 'reducerExtraArgs',\n    reduce = 'reduce',\n    postreduce = 'postreduce',\n    history = 'history'\n}\n\nexport type Reducer<S = unknown, A = unknown, R = S> = (state: S, action: A, ...extraArgs: unknown[]) => R;\n\n/** Describes base process data. */\nexport interface BaseProcessData<S = unknown, A = unknown, EA = A> {\n    /** Supplementary data (value of `settings.data`). */\n    data: unknown;\n    /** List of fulfilled operations (processed actions). */\n    history: Array<HistoryItem<S, A, EA>> | null;\n    /** Settings that have used to define features of processing. */\n    settings: ExtraduceSettings<S, A, EA>;\n    /** Source action that is passed in reducer, or list of actions to be processed. */\n    sourceAction: EA | EA[];\n    /** Source (wrapped) reducer. */\n    sourceReducer: Reducer<S, A>;\n    /** Source state that is passed in reducer. */\n    sourceState: S;\n    /** Current state. */\n    state: S;\n    /** Current processing step. */\n    step: ProcessStep;\n    /** `true`, when current step is ending. */\n    stepEnd: boolean;\n    /** Enumeration of possible values of processing step. */\n    stepSet: typeof ProcessStep;\n    /** `true`, when current step is starting. */\n    stepStart: boolean;\n}\n\n/** Describes current status of data processing. */\nexport interface ProcessData<S = unknown, A = unknown, EA = A> extends BaseProcessData<S, A, EA> {\n    /** Current action that is processed. */\n    action: A | A[] | EA | EA[];\n    /** Index of current action. */\n    actionIndex: number;\n    /** Whether current action is the first action in processing. */\n    firstAction: boolean;\n    /** Whether current action is the last action in processing. */\n    lastAction: boolean;\n    /** State after source (wrapped) reducer is applied for the current action. */\n    reducedState: S;\n    /** State before source (wrapped) reducer is applied for the current action. */\n    startState: S;\n    /** Whether current action is valid and should be passed for reducing. */\n    validAction: boolean;\n}\n\nexport type ProcessingDataField = 'step' | 'stepEnd' | 'stepSet' | 'stepStart' | 'validAction';\n\n/** Describes fulfilled operation (processed action). */\nexport interface HistoryItem<S = unknown, A = unknown, EA = A> extends Omit<ProcessData<S, A, EA>, ProcessingDataField> {\n    /** Time in milliseconds when operation data were saved in history. */\n    time: number;\n}\n\nexport type ReturnUnknown = () => unknown;\n\nexport type ProcessContext<S = unknown, A = unknown, EA = A> = BaseProcessData<S, A, EA> | ProcessData<S, A, EA>;\n\nexport type ActionTransformer<S = unknown, A = unknown, EA = A> = ((action: A | A[] | EA | EA[], data: ProcessData<S, A, EA>) => A | A[]) | ((action: A | A[] | EA | EA[]) => A | A[]);\n\nexport type DataHandler<S = unknown, A = unknown, EA = A> = ((state: S, action: A | A[], data: ProcessData<S, A, EA>) => unknown) | ((state: S, action: A | A[]) => unknown) | ((state: S) => unknown) | ReturnUnknown;\n\nexport type FilterAction<S = unknown, A = unknown, EA = A> = ((action: A | A[] | EA | EA[], data: ProcessData<S, A, EA>) => boolean) | ((action: A | A[] | EA | EA[]) => boolean) | (() => boolean);\n\nexport type GetReducerExtraArgs<S = unknown, A = unknown, EA = A> = ((data: ProcessData<S, A, EA>) => unknown) | ReturnUnknown;\n\nexport type StepHandler<S = unknown, A = unknown, EA = A> = ((step: ProcessStep, data: ProcessContext<S, A, EA>) => unknown) | ((step: ProcessStep) => unknown) | ReturnUnknown;\n\n/**\n * Settings to define features of processing.\n */\nexport interface ExtraduceSettings<S = unknown, A = unknown, EA = A> {\n    /**\n     * Any supplementary data that should be available in processing.\n     */\n    data?: unknown;\n    /**\n     * Function that should be called to test whether current action is valid and should be passed for reducing.\n     * If the function returns `false`, the current action will be ignored (will not be passed into source reducer).\n     * This function is called after a function that is specified in `prepareAction` setting.\n     */\n    filterAction?: FilterAction<S, A, EA>;\n    /**\n     * Size of list of fulfilled operations (processed actions).\n     * `0` (default value) means that data about operations should not be saved in the list.\n     * Negative value (for example `-1`) means that list size is not restricted.\n     */\n    historySize?: number;\n    /**\n     * Function that should be called at the end of each processing step.\n     */\n    onStepEnd?: StepHandler<S, A, EA>;\n    /**\n     * Function that should be called at the start of each processing step.\n     */\n    onStepStart?: StepHandler<S, A, EA>;\n    /**\n     * Function that should be called after source (wrapped) reducer.\n     * State returned by source reducer and current action will be passed into the function.\n     */\n    postreduce?: DataHandler<S, A, EA>;\n    /**\n     * Whether result of `postreduce` function should be used as new state in further processing.\n     * Default value is `false`.\n     */\n    postreduceValueIsState?: boolean;\n    /**\n     * Function that should be called to prepare current action for further processing before filtering.\n     * Value returned by the function will be used as new current action.\n     */\n    prepareAction?: ActionTransformer<S, A, EA>;\n    /**\n     * Function that should be called before source (wrapped) reducer.\n     */\n    prereduce?: DataHandler<S, A, EA>;\n    /**\n     * Whether result of `prereduce` function should be used as new state in further processing.\n     * Default value is `false`.\n     */\n    prereduceValueIsState?: boolean;\n    /**\n     * Whether an array that is passed as action should be treated as list of actions that should be processed separately.\n     * Default value is `true`.\n     */\n    processActionArray?: boolean;\n    /**\n     * Supplementary arguments that should be passed into source (wrapped) reducer besides state and action.\n     * Or a function that returns such arguments.\n     */\n    reducerExtraArgs?: unknown | GetReducerExtraArgs<S, A, EA>;\n    /**\n     * Whether processing of an action that has a falsy value should be skipped.\n     * Default value is `true`.\n     * The corresponding check is made before calling a function that is specified in `filterAction` setting.\n     */\n    skipFalsyAction?: boolean;\n    /**\n     * Function that should be called to transform current valid action after filtering.\n     * Value returned by the function will be used as new current action for further processing.\n     */\n    transformAction?: ActionTransformer<S, A, EA>;\n}\n\n/**\n * Wrap passed reducer to add pre- and post-processing.\n *\n * @param sourceReducer\n *   Source reducer that should be wrapped.\n * @param [settings]\n *   Settings to customize wrapping operation and features of created reducer.\n * @return\n *   New created reducer that can be used instead of source reducer.\n */\nexport default function extraduce<S = unknown, A = unknown, EA = A>(sourceReducer: Reducer<S, A>, settings?: ExtraduceSettings<S, A, EA>): Reducer<S, EA | EA[]> {\n    const options: ExtraduceSettings<S, A, EA> = settings || {};\n    if (! ('processActionArray' in options)) {\n        options.processActionArray = true;\n    }\n    if (! ('skipFalsyAction' in options)) {\n        options.skipFalsyAction = true;\n    }\n    let { historySize } = options;\n    if (typeof historySize !== 'number') {\n        historySize = 0;\n    }\n    const actionHistory: Array<HistoryItem<S, A, EA>> | null = historySize\n        ? []\n        : null;\n\n    return function reducer(sourceState, sourceAction) {\n        const { filterAction, onStepEnd, onStepStart, postreduce, postreduceValueIsState, prepareAction, prereduce, prereduceValueIsState,\n            processActionArray, reducerExtraArgs, skipFalsyAction, transformAction } = options;\n        // eslint-disable-next-line no-nested-ternary\n        const actionList = Array.isArray(sourceAction) && processActionArray\n            ? sourceAction\n            : (isExtraAction<A, EA>(sourceAction)\n                ? sourceAction.payload\n                : [sourceAction]\n            );\n        let state = sourceState;\n        const stepSet = ProcessStep;\n        const data = {\n            sourceReducer,\n            sourceState,\n            sourceAction,\n            state,\n            history: actionHistory,\n            stepSet,\n            settings: options,\n            data: options.data,\n            stepStart: false,\n            stepEnd: false\n        } as ProcessData<S, A, EA>;\n\n        function startStep(step: ProcessStep, context: ProcessContext<S, A, EA>) {\n            context.step = step;\n            if (typeof onStepStart === 'function') {\n                context.stepStart = true;\n                onStepStart(step, context);\n                context.stepStart = false;\n            }\n        }\n\n        function endStep(step: ProcessStep, context: ProcessContext<S, A, EA>) {\n            if (typeof onStepEnd === 'function') {\n                context.stepEnd = true;\n                onStepEnd(step, context);\n                context.stepEnd = false;\n            }\n        }\n\n        startStep(stepSet.process, data as BaseProcessData<S, A, EA>);\n\n        for (let i = 0, len = actionList.length; i < len; i++) {\n            let action: A | A[] | EA | EA[] = actionList[i];\n            data.action = action;\n            data.actionIndex = i;\n            data.firstAction = i === 0;\n            data.lastAction = i === len - 1;\n            data.validAction = true;\n            data.startState = data.reducedState = state;\n\n            if (typeof prepareAction === 'function') {\n                startStep(stepSet.prepareAction, data);\n                action = data.action = prepareAction(action, data);\n                endStep(stepSet.prepareAction, data);\n            }\n            if (skipFalsyAction && ! action) {\n                data.validAction = false;\n            }\n            else if (typeof filterAction === 'function') {\n                startStep(stepSet.filterAction, data);\n                data.validAction = filterAction(action, data);\n                endStep(stepSet.filterAction, data);\n            }\n\n            if (data.validAction) {\n                let value;\n                if (typeof transformAction === 'function') {\n                    startStep(stepSet.transformAction, data);\n                    action = data.action = transformAction(action, data);\n                    endStep(stepSet.transformAction, data);\n                }\n                if (typeof prereduce === 'function') {\n                    startStep(stepSet.prereduce, data);\n                    value = prereduce(state, action as A | A[], data);\n                    if (prereduceValueIsState) {\n                        state = data.state = value as S;\n                    }\n                    endStep(stepSet.prereduce, data);\n                }\n\n                value = [state, action];\n                if (reducerExtraArgs) {\n                    startStep(stepSet.reducerExtraArgs, data);\n                    value = value.concat(\n                        typeof reducerExtraArgs === 'function'\n                            ? reducerExtraArgs(data)\n                            : reducerExtraArgs\n                    );\n                    endStep(stepSet.reducerExtraArgs, data);\n                }\n                startStep(stepSet.reduce, data);\n                state = data.state = sourceReducer(...value as [S, A, ...unknown[]]);\n                data.reducedState = state;\n                endStep(stepSet.reduce, data);\n\n                if (typeof postreduce === 'function') {\n                    startStep(stepSet.postreduce, data);\n                    value = postreduce(state, action as A | A[], data);\n                    if (postreduceValueIsState) {\n                        state = data.state = value as S;\n                    }\n                    endStep(stepSet.postreduce, data);\n                }\n                if (actionHistory) {\n                    startStep(stepSet.history, data);\n                    if (actionHistory.length === historySize) {\n                        actionHistory.shift();\n                    }\n                    value = Object.assign({time: new Date().getTime()}, data) as HistoryItem<S, A, EA> & Partial<Pick< ProcessData<S, A, EA>, ProcessingDataField >>;\n                    delete value.step;\n                    delete value.stepEnd;\n                    delete value.stepSet;\n                    delete value.stepStart;\n                    delete value.validAction;\n                    actionHistory.push(value);\n                    endStep(stepSet.history, data);\n                }\n            }\n        }\n\n        endStep(stepSet.process, data as BaseProcessData<S, A, EA>);\n\n        return state;\n    };\n}\n\nexport {extraduce};\n"],"names":["ProcessStep","extraActionType","isExtraAction","value","Boolean","type","Array","isArray","payload","extraduce","sourceReducer","settings","options","processActionArray","skipFalsyAction","historySize","actionHistory","sourceState","sourceAction","filterAction","onStepEnd","onStepStart","postreduce","postreduceValueIsState","prepareAction","prereduce","prereduceValueIsState","reducerExtraArgs","transformAction","actionList","state","stepSet","data","history","stepStart","stepEnd","startStep","step","context","endStep","process","i","len","length","action","actionIndex","firstAction","lastAction","validAction","startState","reducedState","concat","reduce","shift","Object","assign","time","Date","getTime","push","arguments","actionType"],"mappings":"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"}